# Copilot Instructions

## Architecture & Data Flow
- Flutter app organized under `lib/src`, with each feature split into `domain/` and `presentation/` (e.g. `lib/src/features/user_data_portal`). Keep new code within that structure.
- `main.dart` wires providers: a single `SyncRepository` mediates between the remote `FirestoreRepository` and the local `SharedPreferencesRepository`, exposed through the `DataBaseRepository` interface. Call `SyncRepository` APIs when data should sync.
- Tasks, settings, and prizes use shared JSON models in `lib/src/common/domain/` (`Task`, `Settings`, `Prizes`, `AppUser`). Reuse these models; they already serialize with `toJson()`/`fromJson()`.
- Local persistence relies on `PrefsKeys`; remote writes depend on matching Firestore document layouts in `lib/src/data/firestore_repository.dart`. When adjusting storage schemas, update both implementations together.
- Secure user credentials live in `FlutterSecureStorage` (see `lib/src/data/domain/functions.dart` and the new user data portal). Never read them directly from Firestore.

## Sync & Backups
- `SyncRepository` automatically syncs after mutating methods (`addDaily`, `toggleWeekly`, etc.). If you batch-write or import data, call `repository.triggerSync(force: true)` once at the end.
- Respect the remote-sync opt-out toggle stored via `SyncRepository.getRemoteWriteOptOut()` / `setRemoteWriteOptOut()`. Remote pushes must be gated behind that flag.
- The user data portal (`lib/src/features/user_data_portal/`) exports/imports `.adhd` JSON backups. Exports always include a random bonus prize if available and write to both secure storage metadata and task lists. Maintain schema changes in `UserDataSnapshot`.
- Legacy account switching still lives in `settings/presentation/widgets/load_saved_game.dart`; keep it reachable through the new portal for older accounts.

## UI Patterns
- Settings UI (`lib/src/features/settings/presentation/settings.dart`) uses `OverlayPortal` and custom button widgets (`ConfirmButton`, `CancelButton`). Follow existing styling constants in `Palette` for consistent colors.
- State management is done with `provider`. Acquire repositories via `context.read<DataBaseRepository>()`; avoid creating new instances manually.
- Most modals use `PageRouteBuilder` with fade transitions; mirror that for new overlays to match UX.

## Workflows & Tooling
- Run `flutter pub get` after editing dependencies. (Always acceptable in this workspace.)
- Execute tests with `flutter test`. There is light coverage under `test/` (e.g. `test/prize_manager_weekly_average_test.dart`); add focused tests nearby when modifying domain logic.
- Linting follows `analysis_options.yaml`. Prefer `dart fix --apply` or `flutter analyze` before finishing larger refactors.
- Firebase config is pre-generated in `lib/firebase_options.dart`; when introducing new Firebase services ensure initialization happens in `main.dart` alongside the existing auth and notification setup.

## Integration Gotchas
- Task IDs are generated by `SharedPreferencesRepository` with numeric prefixes; keep that format to avoid collisions with Firestore counters.
- Prize synchronization is daily throttled (`syncPrizesToRemoteIfNeeded`). When adjusting prize awarding, update both local counters and remote scheduling logic.
- Notification schedulers (`DailyQuoteNotifier`, `DeadlineNotifier`) depend on settings changes; if you alter `Settings` fields make sure the notifier flows are kept in sync.

Let me know if any part of this summary feels incomplete or if you need deeper guidance on a specific subsystem.
